# discrete power law distribution, directly cribbed from poweRlaw
dpldis_paretoconv <- function (x, xmin, alpha) {
    #x <- x [round (x) >= round (xmin)]
    xmin <- floor (xmin)
    constant <- VGAM::zeta (alpha)
    if(xmin > 1) 
        constant <- constant - sum ((1:(xmin - 1)) ^ (-alpha))

    -alpha * log (x) - log (constant)
}

#' Compares paretoconv with poweRlaw distributions
#'
#' This function extends directly from the \code{poweRlaw} function of the same
#' name, and compares a discrete power law distribution from the \code{poweRlaw}
#' package with an equivalent convoluted distribution generated by
#' \code{paretoconv}.
#'
#' @param d1 Discrete power law distribution of class \code{displ} from the
#' package \code{poweRlaw}.
#' @param d2 Equivalent convoluted values for the probability density function
#' obtained from \code{paretoconv (..., cdf=FALSE)}
#'
#' @export
#' @examples
#' \dontrun{
#' data ('native_american', package='poweRlaw')
#' m1 <- displ$new(native_american$Cas)
#' m1$setXmin (3)
#' m1$setPars (estimate_pars(m1))
#' x <- sort (unique (native_american$Cas))
#' y <- paretoconv (x=x, a=m1$getPars (), x0=3, n=2, cdf=FALSE, quiet=FALSE)
#' compare_conv_distributions (m1, y)
#' }
compare_conv_distributions <- function (d1, d2) 
{
    if (missing (d1) | missing (d2))
        stop ('Two distributions must be provided')
    if (!is (d1, 'displ'))
        stop ('First argument must be a poweRlaw displ object')
    if (!is.numeric (d2))
        stop ('Second argument must be a vector')

    xs <- sort (d1$getDat ())
    x <- unique (xs)
    if (length (d2) != length (x))
        stop ('Length of second argument does not correspond to data in first argument')
    d2 <- log (d2 [match (xs, x)])

    d1 <- dpldis_paretoconv (xs, d1$getXmin (), d1$getPars ())
    ll_ratio_pts <- d2 - d1 # NOTE: d2 is first!
    m <- mean (ll_ratio_pts [is.finite (ll_ratio_pts)])
    s <- sd (ll_ratio_pts [is.finite (ll_ratio_pts)])
    v <- sqrt (length (ll_ratio_pts)) * m / s
    p1 <- pnorm (v)
  
    if (p1 < 0.5) { p2 <- 2 * p1 } else { p2 <- 2 * (1 - p1) }

    l <- list (test_statistic = v, p_one_sided = 1 - p1, p_two_sided=p2, 
              ratio = data.frame (x=xs, ratio=ll_ratio_pts))
    class(l) <- 'compare_distributions'
    return(l)
}

#' Calculates integral of probability density functions for convoluted Pareto
#' distributions
#'
#' @param a Shape parameter of Pareto disitribution
#' @param x0 Lower cut-off for classic Pareto distribution
#' @param n Number of convolutions
#' @param discrete Calculate integral for discrete (TRUE) or continuous (FALSE)
#' probability density function
#' @param xmin Lower limit of integral (generally 0, 1, or x0)
#' @param quiet If FALSE, progress is displayed as screen output
#'
#' @note Values for discrete integrals differ from values from continuous
#' integrals. This function can also take a long time to execute, particularly
#' for continuous integrals.
#'
#' @export
#' @examples
#' pdf_integral (a=2.1, x0=5, n=0)
pdf_integral <- function (a, x0=1, n=0, discrete=TRUE, xmin=0, quiet=TRUE)
{
    if (missing (a)) stop ('Value of a must be given')

    if (n == 0 & xmin == 0)
    {
        if (!quiet)
            message ('Integrating from lower limit of 1 for n=0')
        xmin <- 1
    }

    if (discrete)
    {
        nx <- 1e5
        x <- x0:nx
        y <- paretoconv (x, a=a, x0=x0, n=n, cdf=FALSE, asymp=TRUE, quiet=quiet)
        ret <- (y [1] + y [length (y)]) / 2 + sum (y [2:(length (y) - 1)])
    } else
    {
        if (!quiet)
            message ('Getting asymptotic limit for convergence to power law')
        xlim <- get_asymp_limit (a=a, x0=x0, n=n, quiet=quiet)
        ylim <- paretoconv (x=xlim, a=a, x0=x0, n=n, cdf=FALSE)

        # Then a function needs to be defined for the integration
        f <- function (x, a, x0, n, xlim, ylim)
        {
            y <- x
            indx1 <- which (x < xlim)
            indx2 <- which (x >= xlim)
            if (length (indx1) > 0)
                y [indx1] <- paretoconv (x [indx1], a=a, x0=x0, n=n, asymp=FALSE)
            if (length (indx2) > 0)
                y [indx2] <- ylim * (x [indx2] / xlim) ^ (-a)
            return (y)
        }

        if (!quiet)
            message ('Calculating integral')

        # And note here that pracma::integral() is much slower than the standard
        # integrate function, and that cubature::hcubature() (the re-named
        # version of adaptIntegrat()) actually doesn't even work for paretoconv.
        ret <- integrate (f, lower=xmin, upper=Inf, a=a, x0=x0, n=n, 
                          xlim=xlim, ylim=ylim)$value
    }
    return (ret)
}
